---
id: hooks-intro
title: Ознайомлення з Хуками
permalink: docs/hooks-intro.html
next: hooks-overview.html
---

*Хуки* - це нововведення у React 16.8. Вони дають можливість використовувати стан та інші особливості React без створення класу.

```js{4,5}
import React, { useState } from 'react';

function Example() {
  // Створюємо нову змінну стану, яку назвемо "count"
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Ви натиснули {count} разів</p>
      <button onClick={() => setCount(count + 1)}>
        Нитисни мене
      </button>
    </div>
  );
}
```

Нова функція `useState` є першим "Хуком", про який ми дізнаємося більше. Цей приклад є лише тизером. Не хвилюйтеся, якщо вам поки що нічого не зрозуміло!

**Почати вивчати хуки можна [на наступній сторінці](/docs/hooks-overview.html).** На цій ми пояснимо чому додаємо Хуки до Реаст та як вони можуть допомогти у написанні класних застосунків.

>Примітка
>
>React 16.8.0 є першим релізом, який підтримує Хуки. При оновленні не забудьте оновити всі бібліотеки, включаючи React DOM. React Native підтримуватиме Хуки в наступній стабільній версії.

## Відео ознайомлення {#video-introduction}

На React Conf 2018, Sophie Alpert та Dan Abramov презентували Хуки разом з Ryan Florence, який показав як використавши Хуки переписати застосунок. Дивіться відео тут:

<br>

<iframe width="650" height="366" src="//www.youtube.com/embed/dpw9EHDh2bM" frameborder="0" allowfullscreen></iframe>

## Без змін існуючого коду {#no-breaking-changes}

Перед тим як ми продовжимо, зверніть увагу що Хуки:

* **Необовʼязкові.** Можна спробувати Хуки в декількох компонентах без переписування будь-якого існуючого коду. Немає нагальної потреби у вивченні чи використанні Хуків якщо вам цього не хочеться.
* **100% зворотна сумісність.** Хуки нічого не ламають.
* **Доступні вже зараз.** Хуки доступні у релізі 16.8.0.

**Ми не маємо планів видаляти класи із React.** Почитати про поступову стратегію впроваження Хуків можна у [нижній частині](#gradual-adoption-strategy) цієї сторінки.

**Хуки не замінюють ваші знання концепцій React** Хуки ж навпаки впроваджуть більш прямі API до концепцій React, які ви вже знаєте: пропси, стан, контекст, рефи та життєві цикли. Ми пізніше вам покажемо як можна комбінувати ці концепції у Хуках.

**Якщо вам лише кортить спробувати Хуки, просимо [перейти на наступну сторінку!](/docs/hooks-overview.html)** Також ви можете залишитися щоб дізнатися більше про те, чому ми додаємо хуки і як збираємося їх використовувати без переписання наших застосунків.

## Що нас спонукало {#motivation}

Хуки вирішують великий діапазон скоріш за все непоєднаних проблем в React, на які ми натрапили при написанні та підтриманні десятків тисяч компонентів протягом пʼяти років. Неважливо чи тільки ви вичаєте React, чи використовуєте його щодня, чи навіть віддаєте перевагу іншій бібліотеці зі схожою системою компонентів, можливо ви впізнаєте деякі з цих проблем.

### Між компонентами вкрай важко перевикористати логіку із відслідкуванням стану {#its-hard-to-reuse-stateful-logic-between-components}

React не має можливості "прикріпити" до компонента поведінку, яку можна перевикористати (наприклад підключення до стору). Якщо ви вже доволі давно працюєте із React, то скоріше за все ви знайомі із такими петернами, як [рендер-пропи](/docs/render-props.html) [та компоненти вищого рівня](/docs/higher-order-components.html), що мають на меті вирішити цю проблему. Але при використанні цих патернів, розробник вимушений реструктурувати компоненти, через що код стає заплутаним та важко зрозумілим. Якщо поглянути у React ДевТулс на типовий застосунок написаний на React, з великою імовірністю ви побачите таку ситуацію, коли компоненти обгортаються у шари провайдерів, споживачів, компонентів вищого порядку, рендер-пропів та інших абстракцій, які ми лагідно назвемо "пекло з обгорток". Незважаючи на те що їх можливо [відфільтрувати у ДевТулс](https://github.com/facebook/react-devtools/pull/503), стає зрозуміло, що необхідно створити кращий спосіб повторного використання логіки із відслідкуванням стану.

Викорисовуючи Хуки з компоненту можливо витягнути логіку, що відслідковує стан, таким чином, щоб забезпечити її самостійне тестування та перевикористання. **З Хуками зʼявляється можливість перевикористання логіки з відслідкуванням стану без зміни ієрархії ваших компонентів.** Через це стає легко ділитися Хуками поміж іншими компонентами чи зі спільнотою.

Поговоримо про це більше у [Написанні власних Хуків](/docs/hooks-custom.html).

### Складні компоненти стає важко розуміти {#complex-components-become-hard-to-understand}

Нам часто доводилося підтримувати компонети, що були простими на початку, але переросли у щось вкрай неконтрольоване, із купою побічних ефектів та логіки із відслідкуванням станів. Кожен життєвий цикл часто містить мікс не повʼязаної між собою логіки. Наприклад, можливо у компоненті у `componentDidMount` та `componentDidUpdate` виконується завантаження даних. При цьому у методі `componentDidMount` може міститися якась не повʼязана логіка, що реєструє обробники подій, та виконує очистку у `componentWillUnmount`. Взаємно повʼязаний код, що спільно змінюється опиняється розбитим на шматки, але зовсім не повʼязані між собою його частини — звʼязаними у одному методі. І це призводить до виникнення помилок та невідповідностей.

В більшості випадків просто неможливо розбити ці компонент на менші через обширну присутність логіки із відслідкуванням станів. А також важко їх тестувати. Саме це і є однією із причин чому багато людей віддають перевагу додаванню сторонніх бібліотек для керування станом. Однак часто це створює складну абстракцію, що призводить до ще важчого перевикористання компонентів та змушує вас перемикатися між різними файлами.

**З Хуками можна розділити один компонент на менші функції базуючись на їхньому спільному призначенні, до прикладу хай то буде встановлення підписки чи завантаження даних**. Це є відмінним від примусового розчеплення з використанням методів життєвих циклів. Ви також можете використовувати редʼюсер для керуванням локальним станом компоненту, і це робить його більш передбачуваним.

Поговоримо про це більше у [Використанні Хуку Ефекту](/docs/hooks-effect.html#tip-use-multiple-effects-to-separate-concerns).

### Поняття класів заплутує як людей, так і компʼютери {#classes-confuse-both-people-and-machines}

Ми зрозуміли що класи окрім складного перевикористання та організації коду, утворюють ще й великий барʼєр до вивчення React. В JavaScript необхідно розуміти механізм роботи `this`, який кардинально відрізняється від інших мов програмування. Потрібно ще привʼязувати обробники подій. А без увімкнення [підтримки синтаксису](https://babeljs.io/docs/en/babel-plugin-transform-class-properties/), що і так є нестабільною, код стає занадто складно описаним. Якщо людям прекрасно зрозуміло що є пропси, стан та потік даних з гори вниз, то класи викликають проблеми. Відмінності між компонентами в React, створені класом чи функцією, а також запитання коли який використовувати навіть досвідчених розробників React приводять до незгод.

Окрім цього, React вже пʼять років і ми хочемо бути певними, що він залишиться доречним в наступні пʼять. Як [Svelte](https://svelte.technology/), [Angular](https://angular.io/), [Glimmer](https://glimmerjs.com/) та інші показують, [попередня компіляція](https://en.wikipedia.org/wiki/Ahead-of-time_compilation) компонентів має потенціал в майбутньому. Особливо якщо вона не обмежується шаблонами. Нещодавно ми експерементували із [загортанням компонентів](https://github.com/facebook/react/issues/7323) використовуючи [Prepack](https://prepack.io/), і навіть перші результати є персективними. Однак, ми збагнули, що у класових компонентах можна ненавмисно утворити такі шаблони, що зведуть нанівець всі попередні оптимізації. Також класи створюють проблеми для сьогоденних інструментів. Наприклад, класи дуже погано мініфікуються, а механізм миттєвого оновлення коду стає дивним та ненадійним. Ми хочемо запропонувати API, із яким код і надалі можна оптимізувати.

**В Хуках можна використовувати більшість можливостей React без написання класів**, вирішуючи попередньо описані проблеми. Згідно нашої концепції компоненти React завжди були ближчими до функцій. Використовуючи функції у Хуках, ми не жертвуюємо практичністю React. Хуки забезпечують доступ до імперативних викликів без необхідності вивчатення складних технік функціонального чи реактивного програмування.

>Приклади
>
>[Огляд Хуків](/docs/hooks-overview.html) є хорошою відправною точкою вивчення Хуків.

## Стратегія поступової адаптації {#gradual-adoption-strategy}

>**TLDR: В нас немає планів зупиняти підтримку класів у React.**

Нам відомо, що розробники React фокусуються на виконанні цілей і не завжди щоразу мають час на перегляд випущеного нового API. Хуки - дуже новий концепт, і тому може бути краще почекати виходу більшої кількості прикладів та посібників перед прийняттям рішення про їхнє вивчення чи використання.

Ми також розуміємо, що поріг додавання нових концепцій в React є досить високим. Тому для зацікавлених, ми підготували [детальний запит про обговорення](https://github.com/reactjs/rfcs/pull/68), в якому знайдете більше деталей та пояснення що нами рухало, а також надає додаткову інформацію щодо технічної імплементації та суміжні речі.

**Важливим є те, що Хуки працюють разом із існуючим кодом, тому їх можна впроваджувати поступово.** Немає необхідності прямо зараз мігрувати на Хуки. Ми рекомендуємо уникати великого переписання коду для складних існуючих класових компонентів. Необхідно докласти трішки зусиль, щоб почати "думати Хуками". Ми виявили, що найкраще спочатку почати використовувати Хуки в нових і не критичних компонентах, а такох впевнитися, що всі в команді комфортно їх можуть використовувати. Після того яки ви спробуєте Хуки, будь ласка, можете [надсилати нам](https://github.com/facebook/react/issues/new) відгуки, неважливо хороші чи погані.

Ми мали на меті покрити Хуками всі існуючі можливі варіанти використання класів, але **ми і надалі будемо підтримувати класові компоненти у найближчому майбутньому.** У Фейсбук, ми написали десятки тисяч компонентів класами, і не прагнемо їх переписувати. Натомість, в новому коді на ряду із класами ми починаємо використовувати Хуки.

## Часті запитання {#frequently-asked-questions}

Знайти відповіді на найпоширеніші запитання про Хуки можна на [сторінці ЧАПІв](/docs/hooks-faq.html).

## Наступні кроки {#next-steps}

Дійшовши кінця, ви вже повинні мати приблизне бачення проблем, які Хуки вирішують, хоча багато подробиць ще залишаються незрозумілими. Не турбуйтеся! **Давайте перейдемо [до наступної сторінки](/docs/hooks-overview.html), де почнемо вивчати Хуки на прикладах.**
