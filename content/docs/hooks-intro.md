---
id: hooks-intro
title: Ознайомлення з Хуками
permalink: docs/hooks-intro.html
next: hooks-overview.html
---

*Хуки* - це нововведення у React 16.8. Вони дають можливість використовувати стан та інші особливості React без створення класу.

```js{4,5}
import React, { useState } from 'react';

function Example() {
  // Створюємо нову змінну стану, яку назвемо "count"
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Ви натиснули {count} разів</p>
      <button onClick={() => setCount(count + 1)}>
        Нитисни мене
      </button>
    </div>
  );
}
```

Нова функція `useState` є першим "Хуком", про який ми дізнаємося більше. Але цкй приклад є лише тизером. Не хвилюйтеся якщо вам поки-що нічого не зрозуміло!

**You can start learning Hooks [on the next page](/docs/hooks-overview.html).** On this page, we'll continue by explaining why we're adding Hooks to React and how they can help you write great applications.
**Почати вивчати хуки можна [на наступній сторінці](/docs/hooks-overview.html).** А на цій ми продовжимо пояснювати чому саме ми додаємо Хуки до React та як вони можуть допомогти у написанні класних застосунків.

>Примітка
>
>React 16.8.0 є першим релізом, який підтримує Хуки. При оновленні не забудьте оновити всі пакунки, включаючи React DOM. React Native підтримуватиме Хуки в наступній стабільній версії.

## Відео ознайомлення {#video-introduction}

На React Conf 2018, Sophie Alpert та Dan Abramov презентували Хуки разом з Ryan Florence, який показував як можна переписати застосунок, використавши Хуки. Дивіться відео тут:

<br>

<iframe width="650" height="366" src="//www.youtube.com/embed/dpw9EHDh2bM" frameborder="0" allowfullscreen></iframe>

## Без змін існуючого коду {#no-breaking-changes}

Перед тим як ми продовжимо, зверніть увагу що Хуки:

* **Повністю опційні.** Можна спробувати Хуки в декількох компонентах без переписування будь-якого існуючого коду. Немає нагальної потреби у вивченні чи використанні Хуків якщо вам цього не хочеться.
* **100% зворотна сумісність.** Хуки не містять змін, що потребують переписання існуючого коду.
* **Доступні вже зараз.** Хуки вже доступні разом з релізом v16.8.0.

**Ми не маємо планів видаляти класи із React.** Почитати про поступову стратегію впроваження Хуків можна у [нижній частині](#gradual-adoption-strategy) цієї сторінки.

**Хуки не замінюють ваші знання концепцій React** Хуки ж навпаки впроваджуть більш прямі API до концепцій React які ви вже знаєте: пропси, стан, контекст, рефи та життєві цикли. Ми пізніше покажемо вам як Хуки cтворюють новий спосіб комбінацїй цих концепцій.

**Якщо вам лише кортить спробувати Хуки, просимо [перейти на наступну сторінку!](/docs/hooks-overview.html)** Також ви можете залишитися щоб дізнатися більше про те, чоми ми додаємо хуки та як ми збираємося їх використовувати без переписання наших застосунків.

## Що нас спонувало {#motivation}

Хуки вирішують великий діапазон скоріш за все непоєднаних проблем в Реакті, на які ми натрапили при написанні та підтриманні десятків тисяч компонентів протягом пʼяти років. Неважливо чи ви тільки вичаєте React, чи використовуєте його щодня, чи навіть віддаєте перевагу іншій бібліотеці зі схожою системою компонентів, можливо ви впізнаєте деякі з цих проблем.

### Перевикористати логіку із відслідкуванням стану між компонентами вкрай важко{#its-hard-to-reuse-stateful-logic-between-components}

React не має можливості "прикріпити" до компонента поведінки, яку можна перевикористати (наприклад підключення до стору). Якщо ви вже доволі давно працюєте із Реактом, то скоріше за все ви знайомі із такими петернами, як [рендер-пропи](/docs/render-props.html) [та компоненти вищого рівня](/docs/higher-order-components.html), що мають на меті вирішити цю проблему. Але при використанні цих патернів, розробник вимушений реструктурувати компоненти, через що код стає заплутаним та його важче розуміти. Якщо поглянути у Реакт ДевТулс на типовий застосунок написаний на Реакт, з великою імовірністю ви побачите таку ситуацію, коли компонети обгорнуті у шари провайдерів, споживачів, компонентів вищого порядку, рендер-пропів та інших абстракцій, які ми назвемо "обгорткове пекло". Незважаючи на те що можливо [їх відфільтрувати у ДевТулс](https://github.com/facebook/react-devtools/pull/503), стає логічно що існує глибинна проблема в Реакт - це кращий спосіб повторного використання логіки із відслідкуванням стану.

Викорисовуючи Хуки можливо витягнути логіку з компоненту, що відслідковує стан таким чином, щоб забезпечити її самостійне тестування та перевикористання. **З Хуками зʼявляється можливість перевикористання логіки з відслідкуванням стану без зміни ієрархії ваших компонентів.** Через це стає легко ділитися Хуками поміж іншими компонентами чи зі спільнотою.

Поговоримо про це більше у [Написанні власних Хуків](/docs/hooks-custom.html).

### Складні компоненти стає важко розуміти {#complex-components-become-hard-to-understand}

Нам часто доводилося підтримувати компонети, що були простими на початку, але переросли у щось вкрай неконтрольоване із купою побічних ефектів та логіки із відслідкуванням станів. Кожен життєвий цикл часто містить мікс не повʼязаної між собою логіки. Наприклад, можливо у компоненті виконується завантаження даних у `componentDidMount` та `componentDidUpdate`. При цьому у цьому самому `componentDidMount` методі може міститися якась не повʼязана логіка, що реєструє обробники подій, та виконує очистку у `componentWillUnmount`. Взаємно повʼязаний код, що спільно змінюється розбивається на шматки, але зовсім не повʼязані між собою його частини опиняються звʼязаними у одному методі. І це призводить до виникнення помилок та невідповідностей.

 В більшості випадків розбити ці компонент на менші через обширну присутність логіки із відслідкуванням станів просто неможливо. А також важко їх тестувати. Саме це і є однією із причин чому багато людей віддають перевагу додаванню сторонніх бібліотек для керування станом. Однак часто це створює складну абстракцію, що призводить до ще важчого перевикористання компонентів та змушує вас перемикатися між різними файлами.

**З Хуками можна розділити один компонент на менші функції базуючись на їхньому спільному призначенні, до прикладу хай то буде встановлення підписки чи завантаження даних**. Що є відмінним від примусового розчеплення з використанням методів життєвих циклів. Ви також маєте можливість використовувати редʼюсер для керуванням локального стану компоненту, що робить його більш передбачуваним.

Поговоримо про це більше у [Використанні Хуку Ефекту](/docs/hooks-effect.html#tip-use-multiple-effects-to-separate-concerns).

### Classes confuse both people and machines {#classes-confuse-both-people-and-machines}
### Поняття класів плутають як люди, так і компʼютери {#classes-confuse-both-people-and-machines}

Ми зрозуміли що класи окрім складного перевикористання та організації коду, ще й утворюють великий барʼєр до вивчення Реакт. В JavaScript необхідно розуміти механізм роботи `this`, який кардинально відрізняється від інших мов програмування. Потрібно ще привʼязувати обробники подій. А без увімкнення [підтримки синтаксису](https://babeljs.io/docs/en/babel-plugin-transform-class-properties/), що і так є нестабільною, код стає занадто складно описаним. Якщо людям прекрасно зрозуміло що є пропси, стан та потік даних з гори вниз, то класи викликають проблеми. Відмінності між компонентами в Реакт, створені класом чи функцією, а також запитання коли який використовувати приводять до незгод навіть серед досвідчених розробників Реакт.

Окрім цього, Реакту вже пʼять років і ми хочемо бути певними, що він залишиться доречним в наступні пʼять. Як As [Svelte](https://svelte.technology/), [Angular](https://angular.io/), [Glimmer](https://glimmerjs.com/) та інші показують, [попередня компіляція](https://en.wikipedia.org/wiki/Ahead-of-time_compilation) компонентів має потенціал в майбутньому. Особливо якщо вона не обмежується шаблонами. Нещодавно ми експерементували із [загортанням компонентів](https://github.com/facebook/react/issues/7323) використовуючи [Prepack](https://prepack.io/), і навіть перші результати є персективними. Однак, ми збагнули, що у компонентах утворених класами можна ненавмисно зробити шаблони, які зводять нанівець всі попередні оптимізації.  Також класи створюють проблеми для сьогоденних інструментів. Наприклад, класи дуже погано мініфікуються, а механізм миттєвого оновлення коду стає дивним та ненадійним. Ми хочемо запропонувати API, з яким код і надалі можна оптимізувати.

Вирішуючи ці проблеми, **в Хуках можна використовувати більшість можливостей Реакт без написання класів**. Згідно нашої концепції компоненти Реакт завжди були ближчими до функції. Заохочуємо використання функцій у Хуках, але не жертвуючи практичністю Реакту. Хуки забезпечують доступ до імперативних викликів без необхідності вивчатення складних технік функціонального чи реактивного програмування.

>Приклади
>
>[Огляд Хуків](/docs/hooks-overview.html) є хорошою відправною точкою вивчення Хуків.

## Gradual Adoption Strategy {#gradual-adoption-strategy}
## Стратегія поступової адаптації {#gradual-adoption-strategy}

>**TLDR: В нас немає планів зупиняти підтримку класів у Реакті.**

Нам відомо що розробники Реакт фокусуються на виконанні завдань і не завжди щоразу мають час на перегляд нового випущеного API. Хуки - дуже новий концепт і тому може бути краще почекати виходу більшої кількості прикладів та посібників перед прийняттям рішення про їхнє вивчення чи використання.

Ми також розуміємо, що поріг додавання нових концепцій в Реакт є досить високим. Тому для зацікавлених, ми підготували [детальний запит про обговорення](https://github.com/reactjs/rfcs/pull/68), в якому знайдете більше деталей та пояснення що нами рухало, а також додаткові ідеї на теми конретиних підходів до проектування і суміжних речей.

**Важливим є те, що Хуки працюють разом із існуючим кодом, тому можна впроваджувати їх поступово.** Немає необхідності прямо зараз мігрувати на Хуки. Ми рекомендуємо уникати великого рефакторінгу для складних існуючих класових компонентів. Необхідно докласти трішки зусиль, щоб почати "думати Хуками". Ми виявили, що спочатку найкраще почати використовувати Хуки в нових і некритичних компонентах, а такох впувнитися що всі в команді комфортно їх використовувати. Після того яки ви спробуєте Хуки, будь ласка можете [надсилати нам](https://github.com/facebook/react/issues/new) відгуки, невадливо хороші чи погані.

Ми мали на меті покрити Хуками всі існуючі можливі використання класів, але **ми і надалі будемо підтримувати класових компонентів і найближчому майбутньому.** У Фейсбук, ми написали десятки тисяч компонентів класами, і тому ми не прагнемо їх переписувати. Натомість, в новому коді на ряду із класами ми починаємо використовувати Хуки. 

## Часті запитання {#frequently-asked-questions}

We've prepared a [Hooks FAQ page](/docs/hooks-faq.html) that answers the most common questions about Hooks.
Знайти відповіді на найпоширеніші запитання про Хуки можна почитати на [сторінці ЧАПІв](/docs/hooks-faq.html).

## Наступні кроки {#next-steps}

Дійшовши кінця, ви вже повинні мати приблизне бачення проблем, які Хуки вирішують, хоча багато подробиць залищаються незрозумілими. Не турбуйтеся! **Давайте перейдемо [до наступної сторінки](/docs/hooks-overview.html), де ми почнемо вивчати Хуки на прикладах.**
